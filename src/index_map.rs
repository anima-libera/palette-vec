//! Map type that maps indices to [`Opsk`]s, but optimized for minimal memory usage.

// Note: There is no `u8` variant, this is because palette vectors of length below 256
// are so small that it probably doesn't make a difference to optimize the index map
// of such OutPalVec more than by using `u16`s.

// TODO: There is in fact no valid situation in which an `opsk_value` requires number size growth
// while the `index_in_key_vec` doesn't.

use std::{cmp::Ordering, fmt::Debug};

use crate::key::{Opsk, PaletteKeyType};

/// Allows faster access by providing hints to the index in the index map to where
/// the access to the entry with some given index in the key vec is.
///
/// Without hint, a binary search is performed.
pub(crate) enum IndexMapAccessOptimizer<'a> {
    /// Provides no hint, regular binary search will be used.
    None,
    /// Provides an index (in map) hint.
    ///
    /// If the access falls into one of the following 3 cases then binary search is skipped:
    /// - Hinted index is the one accessed.
    /// - Hinted index is adjacent to the one accessed.
    /// - The access is for insertion between the hinted index and an adjacent index.
    ///
    /// If the access was not one of these cases then regular binary search is used,
    /// thus a "wrong hint" causes no issue worse than small performance loss.
    ///
    /// The accessed index is written in `self` so that next access can use the current access
    /// as a hint (which will be useful if the next access is made at the same index or at
    /// an adjacent index, for example when iterating).
    Local(&'a mut IndexMapLocalAccessOptimizer),
    /// Indicates that the access will be for insertion at the end of the index map.
    /// **Panics if it is not the case.**
    ///
    /// When pushing in the `OutPalVec` then this is a good access hint.
    Push,
    /// Indicates that the access will be the last valid index of the index map.
    /// **Panics if it is not the case.**
    ///
    /// When popping from the `OutPalVec` then this is a good access hint.
    Pop,
}

/// Mutable index that helps local sequences of access
/// take adventage of the sorting of the map to skip the binary search
/// and find in O(1) and in a cache friendly manner the requested OPSK.
pub(crate) struct IndexMapLocalAccessOptimizer {
    /// Can be out of bounds, it doesn't matter,
    /// it is just a hint that can help skip the binary search or not.
    last_index_in_map: usize,
}

impl IndexMapLocalAccessOptimizer {
    pub(crate) fn new() -> IndexMapLocalAccessOptimizer {
        IndexMapLocalAccessOptimizer {
            last_index_in_map: 0,
        }
    }
}

#[derive(Clone)]
pub(crate) struct IndexMap {
    inner: IndexMapEnum,
}

/// The IndexMap adapts itself to a few different sizes to squeeze better memory usage.
///
/// The branches generated by the matches will be learned by the branch predictor,
/// the performance overhead is so small it isn't worth considering.
#[derive(Clone)]
enum IndexMapEnum {
    U16(IndexMapSized<u16>),
    U32(IndexMapSized<u32>),
    U64(IndexMapSized<u64>),
}

impl IndexMap {
    pub(crate) fn new() -> IndexMap {
        IndexMap {
            inner: IndexMapEnum::U16(IndexMapSized::new()),
        }
    }

    /// Number of entries.
    pub(crate) fn len(&self) -> usize {
        match &self.inner {
            IndexMapEnum::U16(map_sized_u16) => map_sized_u16.len(),
            IndexMapEnum::U32(map_sized_u32) => map_sized_u32.len(),
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64.len(),
        }
    }

    /// Number of entries that could be stored in the currently allocated memory.
    pub(crate) fn capacity(&self) -> usize {
        match &self.inner {
            IndexMapEnum::U16(map_sized_u16) => map_sized_u16.capacity(),
            IndexMapEnum::U32(map_sized_u32) => map_sized_u32.capacity(),
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64.capacity(),
        }
    }

    /// The current size of an entry in this index map, in bytes.
    ///
    /// The size of the allocation in bytes is `self.capacity() * self.entry_size()`.
    pub(crate) fn entry_size(&self) -> usize {
        let number_size = match &self.inner {
            IndexMapEnum::U16(_map_sized_u16) => 2,
            IndexMapEnum::U32(_map_sized_u32) => 4,
            IndexMapEnum::U64(_map_sized_u64) => 8,
        };
        number_size * 2
    }

    /// The biggest size in bytes of any entry in an `IndexMap`
    /// given the length of the `OutPalVec` that contains the index map.
    pub(crate) fn max_entry_size(palvec_length: usize) -> usize {
        let number_size = if palvec_length <= (u16::MAX as usize) {
            2
        } else if palvec_length <= (u32::MAX as usize) {
            4
        } else {
            8
        };
        number_size * 2
    }

    pub(crate) fn set(
        &mut self,
        index_in_key_vec: usize,
        opsk: Opsk,
        access: &mut IndexMapAccessOptimizer,
    ) -> Option<Opsk> {
        match &mut self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                let max = index_in_key_vec.max(opsk.value);
                if (u16::MAX as usize) < max {
                    self.grow_number_size_to_accomodate(max);
                    // Re-run the match, it is no longer u16.
                    // This is a super rare path so it is ok if it is dumb.
                    return self.set(index_in_key_vec, opsk, access);
                }
                // We made sure these values fit in the current number type.
                let previous =
                    map_sized_u16.set(index_in_key_vec as u16, opsk.value as u16, access);
                previous.map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U32(map_sized_u32) => {
                let max = index_in_key_vec.max(opsk.value);
                if (u32::MAX as usize) < max {
                    self.grow_number_size_to_accomodate(max);
                    // Re-run the match, it is no longer u32.
                    // This is a super rare path so it is ok if it is dumb.
                    return self.set(index_in_key_vec, opsk, access);
                }
                // We made sure these values fit in the current number type.
                let previous =
                    map_sized_u32.set(index_in_key_vec as u32, opsk.value as u32, access);
                previous.map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U64(map_sized_u64) => {
                let previous =
                    map_sized_u64.set(index_in_key_vec as u64, opsk.value as u64, access);
                previous.map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
        }
    }

    pub(crate) fn get(
        &self,
        index_in_key_vec: usize,
        access: &mut IndexMapAccessOptimizer,
    ) -> Option<Opsk> {
        match &self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                // If the index doesn't fit in the current number type then it is out of bounds.
                let index_in_key_vec: u16 = index_in_key_vec.try_into().ok()?;
                map_sized_u16
                    .get(index_in_key_vec, access)
                    .map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U32(map_sized_u32) => {
                // If the index doesn't fit in the current number type then it is out of bounds.
                let index_in_key_vec: u32 = index_in_key_vec.try_into().ok()?;
                map_sized_u32
                    .get(index_in_key_vec, access)
                    .map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64
                .get(index_in_key_vec as u64, access)
                .map(|opsk_value| Opsk::with_value(opsk_value as usize)),
        }
    }

    pub(crate) fn remove(
        &mut self,
        index_in_key_vec: usize,
        access: &mut IndexMapAccessOptimizer,
    ) -> Option<Opsk> {
        match &mut self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                // If the index doesn't fit in the current number type then it is out of bounds.
                let index_in_key_vec: u16 = index_in_key_vec.try_into().ok()?;
                map_sized_u16
                    .remove(index_in_key_vec, access)
                    .map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U32(map_sized_u32) => {
                // If the index doesn't fit in the current number type then it is out of bounds.
                let index_in_key_vec: u32 = index_in_key_vec.try_into().ok()?;
                map_sized_u32
                    .remove(index_in_key_vec, access)
                    .map(|opsk_value| Opsk::with_value(opsk_value as usize))
            }
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64
                .remove(index_in_key_vec as u64, access)
                .map(|opsk_value| Opsk::with_value(opsk_value as usize)),
        }
    }

    pub(crate) fn remove_all_with_opsk(
        &mut self,
        opsk_value_to_remove: Opsk,
        callback_on_removed_entries: impl FnMut(usize),
    ) {
        match &mut self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                // If the opsk doesn't fit in the current number type then there are none.
                let Ok(opsk_value_to_remove): Result<u16, _> =
                    opsk_value_to_remove.value.try_into()
                else {
                    return;
                };
                map_sized_u16
                    .remove_all_with_opsk(opsk_value_to_remove, callback_on_removed_entries);
            }
            IndexMapEnum::U32(map_sized_u32) => {
                // If the opsk doesn't fit in the current number type then there are none.
                let Ok(opsk_value_to_remove): Result<u32, _> =
                    opsk_value_to_remove.value.try_into()
                else {
                    return;
                };
                map_sized_u32
                    .remove_all_with_opsk(opsk_value_to_remove, callback_on_removed_entries);
            }
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64.remove_all_with_opsk(
                opsk_value_to_remove.value as u64,
                callback_on_removed_entries,
            ),
        }
    }

    pub(crate) fn add_many_entries(&mut self, how_many: usize) -> AddManyEntries<'_> {
        AddManyEntries::for_map(self, how_many)
    }

    /// Use a bigger number size to accomodate the given number that doesn't fit yet.
    /// Growing means using `u32` or `u64` instead of `u16`, or using `u64` instead of `u32`.
    fn grow_number_size_to_accomodate(&mut self, to_what_number: usize) {
        let empty_map = IndexMapEnum::U16(IndexMapSized { vec: vec![] });
        let map = std::mem::replace(&mut self.inner, empty_map);
        match map {
            IndexMapEnum::U16(map_sized_u16) => {
                if to_what_number <= (u16::MAX as usize) {
                    panic!("Bug: grow_to_accomodate called when unnecessary");
                } else if to_what_number <= (u32::MAX as usize) {
                    self.inner = IndexMapEnum::U32(IndexMapSized::from_other_map(map_sized_u16));
                } else {
                    self.inner = IndexMapEnum::U64(IndexMapSized::from_other_map(map_sized_u16));
                }
            }
            IndexMapEnum::U32(map_sized_u32) => {
                if to_what_number <= (u32::MAX as usize) {
                    panic!("Bug: grow_to_accomodate called when unnecessary");
                } else {
                    self.inner = IndexMapEnum::U64(IndexMapSized::from_other_map(map_sized_u32));
                }
            }
            IndexMapEnum::U64(_map_sized_u64) => {
                panic!("Bug: grow_to_accomodate called when unnecessary");
            }
        }
    }

    /// Breaks the "always sorted" invariant by adding that many dummy entries at the end.
    unsafe fn add_many_dummy_entries(&mut self, how_many: usize) {
        match &mut self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                map_sized_u16.add_many_dummy_entries(how_many);
            }
            IndexMapEnum::U32(map_sized_u32) => {
                map_sized_u32.add_many_dummy_entries(how_many);
            }
            IndexMapEnum::U64(map_sized_u64) => {
                map_sized_u64.add_many_dummy_entries(how_many);
            }
        }
    }

    unsafe fn get_entry_at_map_index(&self, index_in_map: usize) -> (usize, Opsk) {
        match &self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                let entry = map_sized_u16.get_entry_at_map_index(index_in_map);
                (entry.0 as usize, Opsk::with_value(entry.1 as usize))
            }
            IndexMapEnum::U32(map_sized_u32) => {
                let entry = map_sized_u32.get_entry_at_map_index(index_in_map);
                (entry.0 as usize, Opsk::with_value(entry.1 as usize))
            }
            IndexMapEnum::U64(map_sized_u64) => {
                let entry = map_sized_u64.get_entry_at_map_index(index_in_map);
                (entry.0 as usize, Opsk::with_value(entry.1 as usize))
            }
        }
    }

    unsafe fn set_entry_at_map_index(
        &mut self,
        index_in_map: usize,
        index_in_key_vec: usize,
        opsk: Opsk,
    ) {
        match &mut self.inner {
            IndexMapEnum::U16(map_sized_u16) => {
                let max = index_in_key_vec.max(opsk.value);
                if (u16::MAX as usize) < max {
                    self.grow_number_size_to_accomodate(max);
                    // Re-run the match, it is no longer u16.
                    // This is a super rare path so it is ok if it is dumb.
                    return self.set_entry_at_map_index(index_in_map, index_in_key_vec, opsk);
                }
                // We made sure these values fit in the current number type.
                map_sized_u16.set_entry_at_map_index(
                    index_in_map,
                    index_in_key_vec as u16,
                    opsk.value as u16,
                );
            }
            IndexMapEnum::U32(map_sized_u32) => {
                let max = index_in_key_vec.max(opsk.value);
                if (u32::MAX as usize) < max {
                    self.grow_number_size_to_accomodate(max);
                    // Re-run the match, it is no longer u32.
                    // This is a super rare path so it is ok if it is dumb.
                    return self.set_entry_at_map_index(index_in_map, index_in_key_vec, opsk);
                }
                // We made sure these values fit in the current number type.
                map_sized_u32.set_entry_at_map_index(
                    index_in_map,
                    index_in_key_vec as u32,
                    opsk.value as u32,
                );
            }
            IndexMapEnum::U64(map_sized_u64) => {
                map_sized_u64.set_entry_at_map_index(
                    index_in_map,
                    index_in_key_vec as u64,
                    opsk.value as u64,
                );
            }
        }
    }
}

impl Debug for IndexMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.inner {
            IndexMapEnum::U16(map_sized_u16) => map_sized_u16.fmt(f),
            IndexMapEnum::U32(map_sized_u32) => map_sized_u32.fmt(f),
            IndexMapEnum::U64(map_sized_u64) => map_sized_u64.fmt(f),
        }
    }
}

trait NumberType
where
    Self: Clone + Copy + Ord + TryFrom<usize> + TryInto<usize> + Default + Debug,
{
}
impl NumberType for u16 {}
impl NumberType for u32 {}
impl NumberType for u64 {}

#[derive(Clone, Copy)]
struct IndexMapEntry<N>
where
    N: NumberType,
{
    index_in_key_vec: N,
    opsk_value: N,
}

#[derive(Clone)]
struct IndexMapSized<N>
where
    N: NumberType,
{
    /// Always sorted per their `index_in_key_vec` field
    /// so that finding the entry for a given `index_in_key_vec` can be done in log(len)
    /// via `[T]::binary_search_by_key`.
    ///
    /// There are no multiple entries that share a same `index_in_key_vec`.
    vec: Vec<IndexMapEntry<N>>,
}

impl<N> IndexMapSized<N>
where
    N: NumberType,
{
    fn new() -> IndexMapSized<N> {
        IndexMapSized { vec: vec![] }
    }

    fn from_other_map<M>(other_map: IndexMapSized<M>) -> IndexMapSized<N>
    where
        M: NumberType,
        N: TryFrom<M>,
        <N as TryFrom<M>>::Error: Debug,
    {
        let mut map: IndexMapSized<N> = IndexMapSized {
            vec: Vec::with_capacity(other_map.vec.capacity()),
        };
        for entry in other_map.vec.into_iter() {
            map.vec.push(IndexMapEntry {
                index_in_key_vec: TryInto::<N>::try_into(entry.index_in_key_vec).unwrap(),
                opsk_value: TryInto::<N>::try_into(entry.opsk_value).unwrap(),
            });
        }
        map
    }

    fn len(&self) -> usize {
        self.vec.len()
    }

    fn capacity(&self) -> usize {
        self.vec.capacity()
    }

    /// Returns what `self.vec.binary_search_by_key` would return.
    ///
    /// Uses the hint given by the [`IndexMapAccessOptimizer`] if any and if it is right
    /// to avoid having to do the binary search if we can.
    fn access(
        &self,
        index_in_key_vec: N,
        access: &mut IndexMapAccessOptimizer,
    ) -> Result<usize, usize> {
        let index_in_map = (match access {
            IndexMapAccessOptimizer::Local(ref access) => {
                let try_index = access.last_index_in_map;
                if let Some(entry) = self.vec.get(try_index) {
                    match entry.index_in_key_vec.cmp(&index_in_key_vec) {
                        Ordering::Equal => Some(Ok(try_index)),
                        Ordering::Greater => {
                            if let Some(try_index_minus_one) = try_index.checked_sub(1) {
                                if let Some(previous_entry) = self.vec.get(try_index_minus_one) {
                                    match previous_entry.index_in_key_vec.cmp(&index_in_key_vec) {
                                        Ordering::Equal => Some(Ok(try_index_minus_one)),
                                        Ordering::Less => Some(Err(try_index)),
                                        Ordering::Greater => None,
                                    }
                                } else {
                                    Some(Err(0))
                                }
                            } else {
                                // TODO: Fix this one? There might be Some answer here.
                                None
                            }
                        }
                        Ordering::Less => {
                            if let Some(next_entry) = self.vec.get(try_index + 1) {
                                match next_entry.index_in_key_vec.cmp(&index_in_key_vec) {
                                    Ordering::Equal => Some(Ok(try_index + 1)),
                                    Ordering::Greater => Some(Err(try_index + 1)),
                                    Ordering::Less => None,
                                }
                            } else {
                                Some(Err(self.vec.len()))
                            }
                        }
                    }
                } else {
                    None
                }
            }
            IndexMapAccessOptimizer::Push => {
                let len = self.vec.len();
                if let Some(last_index) = len.checked_sub(1) {
                    let last_entry = self.vec.get(last_index).unwrap();
                    assert!(
                        last_entry.index_in_key_vec < index_in_key_vec,
                        "Bug: Push hint used with an index_in_key_vec before the last"
                    );
                }
                Some(Err(len))
            }
            IndexMapAccessOptimizer::Pop => {
                let len = self.vec.len();
                if let Some(last_index) = len.checked_sub(1) {
                    let last_entry = self.vec.get(last_index).unwrap();
                    assert_eq!(
                        last_entry.index_in_key_vec, index_in_key_vec,
                        "Bug: Pop hint used with an index_in_key_vec not equal to the last"
                    );
                    Some(Ok(last_index))
                } else {
                    None
                }
            }
            IndexMapAccessOptimizer::None => None,
        })
        .unwrap_or_else(|| {
            self.vec
                .binary_search_by_key(&index_in_key_vec, |entry| entry.index_in_key_vec)
        });
        if let IndexMapAccessOptimizer::Local(access) = access {
            match index_in_map {
                Ok(index_in_map) | Err(index_in_map) => access.last_index_in_map = index_in_map,
            }
        }
        index_in_map
    }

    fn set(
        &mut self,
        index_in_key_vec: N,
        opsk_value: N,
        access: &mut IndexMapAccessOptimizer,
    ) -> Option<N> {
        let index_in_map = self.access(index_in_key_vec, access);
        match index_in_map {
            Ok(index_in_map) => {
                let entry = self.vec.get_mut(index_in_map).unwrap();
                let previous = entry.opsk_value;
                entry.opsk_value = opsk_value;
                Some(previous)
            }
            Err(index_in_map) => {
                self.vec.insert(
                    index_in_map,
                    IndexMapEntry {
                        index_in_key_vec,
                        opsk_value,
                    },
                );
                None
            }
        }
    }

    fn get(&self, index_in_key_vec: N, access: &mut IndexMapAccessOptimizer) -> Option<N> {
        let index_in_map = self.access(index_in_key_vec, access).ok()?;
        Some(self.vec[index_in_map].opsk_value)
    }

    fn remove(&mut self, index_in_key_vec: N, access: &mut IndexMapAccessOptimizer) -> Option<N> {
        let index_in_map = self.access(index_in_key_vec, access).ok()?;
        Some(self.vec.remove(index_in_map).opsk_value)
    }

    fn remove_all_with_opsk(
        &mut self,
        opsk_value_to_remove: N,
        mut callback_on_removed_entries: impl FnMut(usize),
    ) where
        <N as TryInto<usize>>::Error: Debug,
    {
        let mut next_available_index_in_map = 0;
        for index_in_map in 0..self.vec.len() {
            if self.vec[index_in_map].opsk_value == opsk_value_to_remove {
                // Not doing anything here will discard this entry:
                // it will either be overwritten by a preserved entry or be truncated away.
                callback_on_removed_entries(
                    self.vec[index_in_map].index_in_key_vec.try_into().unwrap(),
                );
            } else {
                // Keeping this one. Order is preserved.
                self.vec[next_available_index_in_map] = self.vec[index_in_map];
                next_available_index_in_map += 1;
            }
        }
        let new_smaller_len = next_available_index_in_map;
        self.vec.truncate(new_smaller_len);
    }

    /// Breaks the "always sorted" invariant by adding that many dummy entries at the end.
    unsafe fn add_many_dummy_entries(&mut self, how_many: usize) {
        self.vec.resize(
            self.vec.len() + how_many,
            IndexMapEntry {
                index_in_key_vec: N::default(),
                opsk_value: N::default(),
            },
        );
    }

    unsafe fn get_entry_at_map_index(&self, index_in_map: usize) -> (N, N) {
        let entry = self.vec[index_in_map];
        (entry.index_in_key_vec, entry.opsk_value)
    }

    unsafe fn set_entry_at_map_index(
        &mut self,
        index_in_map: usize,
        index_in_key_vec: N,
        opsk_value: N,
    ) {
        self.vec[index_in_map] = IndexMapEntry {
            index_in_key_vec,
            opsk_value,
        };
    }
}

pub(crate) struct AddManyEntries<'a> {
    index_map: &'a mut IndexMap,
    /// The adding of many entries via this API is only optimized because
    /// we know before starting exactly how many entries will be added this way,
    /// this counter enforces that this information was correct in the end.
    remaining_entries_to_add_count: usize,
    /// Next added entry must have a strictly smaller `index_in_key_vec`.
    /// The entries must be added in order from biggest to smallest `index_in_key_vec`.
    last_index_in_key_vec_added: Option<usize>,
    /// Next entries (added or preserved) treated just now will be put one slot left to this one.
    /// This goes from right to left.
    /// If there are no slots on the left (it is 0) then we should be done anyway.
    /// It starts at len (so at the beginning it is not a valid index).
    last_index_in_map_for_treated_entries: usize,
    /// Next preserved entries not yet treated will be taken one slot left to this one.
    /// This goes from right to left.
    /// If there are no slots on the left (it is 0) then there is no more old entries to preserve.
    last_index_in_map_for_old_entries: usize,
}

impl<'a> AddManyEntries<'a> {
    fn for_map(
        index_map: &mut IndexMap,
        how_many_entries_will_be_added: usize,
    ) -> AddManyEntries<'_> {
        let old_len = index_map.len();
        // SAFETY: The `AddManyEntries` API makes sure that the "always sorted" invariant
        // on IndexMap's vec of entries is respected at the end of the operation
        // when `AddManyEntries::finish` is called and the map is not borrowed anymore.
        unsafe { index_map.add_many_dummy_entries(how_many_entries_will_be_added) }
        let new_len = index_map.len();
        AddManyEntries {
            index_map,
            remaining_entries_to_add_count: how_many_entries_will_be_added,
            last_index_in_key_vec_added: None,
            last_index_in_map_for_treated_entries: new_len,
            last_index_in_map_for_old_entries: old_len,
        }
    }

    pub(crate) fn add_entry(&mut self, index_in_key_vec: usize, opsk: Opsk) {
        assert!(
            self.last_index_in_key_vec_added.is_none()
                || self
                    .last_index_in_key_vec_added
                    .is_some_and(|last_index| index_in_key_vec < last_index),
            "Bug: entries not added in descending order of their index in key vec"
        );
        // Preserve old entries that must be treated before the added entry.
        #[allow(clippy::while_let_loop)]
        loop {
            let next_index_in_map_for_old_entries =
                self.last_index_in_map_for_old_entries.checked_sub(1);
            if let Some(next_index_in_map_for_old_entries) = next_index_in_map_for_old_entries {
                let next_index_in_key_vec_to_preserve = {
                    // SAFETY: TODO (it is not even that unsafe really)
                    unsafe {
                        self.index_map
                            .get_entry_at_map_index(next_index_in_map_for_old_entries)
                            .0
                    }
                };
                debug_assert_ne!(index_in_key_vec, next_index_in_key_vec_to_preserve);
                if index_in_key_vec < next_index_in_key_vec_to_preserve {
                    self.preserve_one();
                } else {
                    // The added entry shall now be treated as its index in key vec
                    // is bigger than the one of the next old entry to preserve.
                    break;
                }
            } else {
                // The added entry is threated now as there is no more old entries to preserve.
                break;
            }
        }
        // Treat the added entry.
        let Some(next_index_in_map_for_treated_entries) =
            self.last_index_in_map_for_treated_entries.checked_sub(1)
        else {
            debug_assert_eq!(self.remaining_entries_to_add_count, 0);
            panic!("Bug: adding an entry more than the announced amount");
        };
        // SAFETY: TODO (the index is valid because <explanation lol>)
        unsafe {
            self.index_map.set_entry_at_map_index(
                next_index_in_map_for_treated_entries,
                index_in_key_vec,
                opsk,
            );
        }
        self.last_index_in_map_for_treated_entries = next_index_in_map_for_treated_entries;
        self.last_index_in_key_vec_added = Some(index_in_key_vec);
        self.remaining_entries_to_add_count = self
            .remaining_entries_to_add_count
            .checked_sub(1)
            .expect("Bug: adding an entry more than the announced amount");
    }

    fn preserve_one(&mut self) {
        //take the next old entry to preserve and put it at the insertion site
        let next_index_in_map_for_old_entries = self.last_index_in_map_for_old_entries - 1;
        let next_index_in_map_for_treated_entries = self.last_index_in_map_for_treated_entries - 1;
        let entry = {
            // SAFETY: TODO (the index is valid because <explanation lol>)
            unsafe {
                self.index_map
                    .get_entry_at_map_index(next_index_in_map_for_old_entries)
            }
        };
        // SAFETY: TODO (the index is valid because <explanation lol>)
        unsafe {
            self.index_map.set_entry_at_map_index(
                next_index_in_map_for_treated_entries,
                entry.0,
                entry.1,
            );
        }
        self.last_index_in_map_for_old_entries = next_index_in_map_for_old_entries;
        self.last_index_in_map_for_treated_entries = next_index_in_map_for_treated_entries;
    }

    pub(crate) fn finish(self) {
        if self.remaining_entries_to_add_count != 0 {
            panic!("Bug: finishing AddManyEntries before adding the announced amount");
        }
    }
}

impl<N> Debug for IndexMapSized<N>
where
    N: NumberType,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_map = f.debug_map();
        for entry in self.vec.iter() {
            debug_map.entry(&entry.index_in_key_vec, &entry.opsk_value);
        }
        debug_map.finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use IndexMapAccessOptimizer as A;

    #[test]
    fn access_empty_returns_none() {
        let index_map = IndexMap::new();
        assert_eq!(index_map.get(0, &mut A::None), None);
    }

    #[test]
    fn set_and_get() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(1, Opsk::with_value(1), &mut A::None);
        index_map.set(2, Opsk::with_value(50), &mut A::None);
        index_map.set(70, Opsk::with_value(50), &mut A::None);
        index_map.set(3, Opsk::with_value(50), &mut A::None);
        index_map.set(8, Opsk::with_value(100), &mut A::None);
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(1, &mut A::None), Some(Opsk::with_value(1)));
        assert_eq!(index_map.get(2, &mut A::None), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(3, &mut A::None), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(8, &mut A::None), Some(Opsk::with_value(100)));
        assert_eq!(index_map.get(70, &mut A::None), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(4, &mut A::None), None);
        assert_eq!(index_map.get(69, &mut A::None), None);
        assert_eq!(index_map.get(71, &mut A::None), None);
    }

    #[test]
    fn doesnt_grow_if_not_needed() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(
            u16::MAX as usize,
            Opsk::with_value(u16::MAX as usize),
            &mut A::None,
        );
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(
            index_map.get(u16::MAX as usize, &mut A::None),
            Some(Opsk::with_value(u16::MAX as usize))
        );
        assert_eq!(index_map.get(1, &mut A::None), None);
        assert_eq!(index_map.get(u16::MAX as usize - 1, &mut A::None), None);
        assert!(matches!(index_map.inner, IndexMapEnum::U16(_)));
    }

    #[test]
    fn grows_if_needed() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(
            u16::MAX as usize,
            Opsk::with_value(u16::MAX as usize),
            &mut A::None,
        );
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(
            index_map.get(u16::MAX as usize, &mut A::None),
            Some(Opsk::with_value(u16::MAX as usize))
        );
        assert_eq!(index_map.get(1, &mut A::None), None);
        assert_eq!(index_map.get(u16::MAX as usize - 1, &mut A::None), None);
        assert!(matches!(index_map.inner, IndexMapEnum::U16(_)));

        index_map.set(u16::MAX as usize + 1, Opsk::with_value(42), &mut A::None);
        assert!(matches!(index_map.inner, IndexMapEnum::U32(_)));
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(
            index_map.get(u16::MAX as usize, &mut A::None),
            Some(Opsk::with_value(u16::MAX as usize))
        );
        assert_eq!(index_map.get(1, &mut A::None), None);
        assert_eq!(index_map.get(u16::MAX as usize - 1, &mut A::None), None);
        assert_eq!(
            index_map.get(u16::MAX as usize + 1, &mut A::None),
            Some(Opsk::with_value(42))
        );
        index_map.set(
            u32::MAX as usize,
            Opsk::with_value(u32::MAX as usize),
            &mut A::None,
        );
        assert!(matches!(index_map.inner, IndexMapEnum::U32(_)));

        index_map.set(u32::MAX as usize + 1, Opsk::with_value(3), &mut A::None);
        assert!(matches!(index_map.inner, IndexMapEnum::U64(_)));
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(
            index_map.get(u32::MAX as usize + 1, &mut A::None),
            Some(Opsk::with_value(3))
        );
    }

    #[test]
    fn can_fit_max_values() {
        let mut index_map = IndexMap::new();
        index_map.set(
            u64::MAX as usize,
            Opsk::with_value(u64::MAX as usize),
            &mut A::None,
        );
        assert_eq!(
            index_map.get(u64::MAX as usize, &mut A::None),
            Some(Opsk::with_value(u64::MAX as usize))
        );
    }

    #[test]
    fn remove() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(1, Opsk::with_value(2), &mut A::None);
        index_map.set(10, Opsk::with_value(20), &mut A::None);
        index_map.set(100, Opsk::with_value(200), &mut A::None);
        index_map.set(1000, Opsk::with_value(2000), &mut A::None);
        index_map.set(10000, Opsk::with_value(20000), &mut A::None);
        assert_eq!(index_map.remove(1, &mut A::None), Some(Opsk::with_value(2)));
        assert_eq!(
            index_map.remove(1000, &mut A::None),
            Some(Opsk::with_value(2000))
        );
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(1, &mut A::None), None);
        assert_eq!(index_map.get(10, &mut A::None), Some(Opsk::with_value(20)));
        assert_eq!(
            index_map.get(100, &mut A::None),
            Some(Opsk::with_value(200))
        );
        assert_eq!(index_map.get(1000, &mut A::None), None);
        assert_eq!(
            index_map.get(10000, &mut A::None),
            Some(Opsk::with_value(20000))
        );
    }

    #[test]
    fn remove_all_with_opsk() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(1, Opsk::with_value(0), &mut A::None);
        index_map.set(2, Opsk::with_value(1), &mut A::None);
        index_map.set(3, Opsk::with_value(1), &mut A::None);
        index_map.set(4, Opsk::with_value(0), &mut A::None);
        index_map.set(5, Opsk::with_value(1), &mut A::None);
        index_map.set(6, Opsk::with_value(0), &mut A::None);
        index_map.set(7, Opsk::with_value(1), &mut A::None);
        index_map.remove_all_with_opsk(Opsk::with_value(1), |_index_in_key_vec| {});
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(1, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(2, &mut A::None), None);
        assert_eq!(index_map.get(3, &mut A::None), None);
        assert_eq!(index_map.get(4, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(5, &mut A::None), None);
        assert_eq!(index_map.get(6, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(7, &mut A::None), None);
    }

    #[test]
    fn add_many_entries() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(5, Opsk::with_value(5), &mut A::None);
        index_map.set(10000, Opsk::with_value(10000), &mut A::None);
        let mut add_many_entries = index_map.add_many_entries(20);
        for i in (20..35).rev() {
            add_many_entries.add_entry(i, Opsk::with_value(i));
        }
        add_many_entries.add_entry(10, Opsk::with_value(10));
        add_many_entries.add_entry(9, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(8, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(7, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(2, Opsk::with_value(2));
        add_many_entries.finish();
        assert_eq!(index_map.get(0, &mut A::None), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(1, &mut A::None), None);
        assert_eq!(index_map.get(2, &mut A::None), Some(Opsk::with_value(2)));
        assert_eq!(index_map.get(5, &mut A::None), Some(Opsk::with_value(5)));
        assert_eq!(
            index_map.get(7, &mut A::None),
            Some(Opsk::with_value(u32::MAX as usize))
        );
        assert_eq!(
            index_map.get(8, &mut A::None),
            Some(Opsk::with_value(u32::MAX as usize))
        );
        assert_eq!(
            index_map.get(9, &mut A::None),
            Some(Opsk::with_value(u32::MAX as usize))
        );
        assert_eq!(index_map.get(10, &mut A::None), Some(Opsk::with_value(10)));
        assert_eq!(index_map.get(19, &mut A::None), None);
        for i in 20..35 {
            assert_eq!(index_map.get(i, &mut A::None), Some(Opsk::with_value(i)));
        }
        assert_eq!(index_map.get(35, &mut A::None), None);
        assert_eq!(
            index_map.get(10000, &mut A::None),
            Some(Opsk::with_value(10000))
        );
    }

    #[test]
    #[should_panic]
    fn add_many_entries_but_not_in_the_right_order() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(5, Opsk::with_value(5), &mut A::None);
        index_map.set(10000, Opsk::with_value(10000), &mut A::None);
        let mut add_many_entries = index_map.add_many_entries(20);
        for i in (20..35).rev() {
            add_many_entries.add_entry(i, Opsk::with_value(i));
        }
        add_many_entries.add_entry(9, Opsk::with_value(u32::MAX as usize));
        // Aha! Wrong order here, the indices should only be descending.
        add_many_entries.add_entry(10, Opsk::with_value(10));
        add_many_entries.add_entry(8, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(7, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(2, Opsk::with_value(2));
        add_many_entries.finish();
    }

    #[test]
    #[should_panic]
    fn add_many_entries_but_not_enough() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(5, Opsk::with_value(5), &mut A::None);
        index_map.set(10000, Opsk::with_value(10000), &mut A::None);
        let mut add_many_entries = index_map.add_many_entries(20);
        for i in (20..35).rev() {
            add_many_entries.add_entry(i, Opsk::with_value(i));
        }
        add_many_entries.add_entry(10, Opsk::with_value(10));
        add_many_entries.add_entry(9, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(8, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(7, Opsk::with_value(u32::MAX as usize));
        // We are still missing one.
        add_many_entries.finish();
    }

    #[test]
    #[should_panic]
    fn add_many_entries_but_too_many() {
        let mut index_map = IndexMap::new();
        index_map.set(0, Opsk::with_value(0), &mut A::None);
        index_map.set(5, Opsk::with_value(5), &mut A::None);
        index_map.set(10000, Opsk::with_value(10000), &mut A::None);
        let mut add_many_entries = index_map.add_many_entries(20);
        for i in (20..35).rev() {
            add_many_entries.add_entry(i, Opsk::with_value(i));
        }
        add_many_entries.add_entry(10, Opsk::with_value(10));
        add_many_entries.add_entry(9, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(8, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(7, Opsk::with_value(u32::MAX as usize));
        add_many_entries.add_entry(2, Opsk::with_value(2));
        // One too many.
        add_many_entries.add_entry(1, Opsk::with_value(1));
        add_many_entries.finish();
    }

    #[test]
    fn access_hint() {
        let mut index_map = IndexMap::new();
        let mut local_access = IndexMapLocalAccessOptimizer::new();
        let mut access = IndexMapAccessOptimizer::Local(&mut local_access);
        index_map.set(0, Opsk::with_value(0), &mut access);
        index_map.set(1, Opsk::with_value(1), &mut access);
        index_map.set(2, Opsk::with_value(50), &mut access);
        index_map.set(70, Opsk::with_value(50), &mut access);
        index_map.set(3, Opsk::with_value(50), &mut access);
        index_map.set(8, Opsk::with_value(100), &mut access);
        assert_eq!(index_map.get(0, &mut access), Some(Opsk::with_value(0)));
        assert_eq!(index_map.get(1, &mut access), Some(Opsk::with_value(1)));
        assert_eq!(index_map.get(2, &mut access), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(3, &mut access), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(8, &mut access), Some(Opsk::with_value(100)));
        assert_eq!(index_map.get(70, &mut access), Some(Opsk::with_value(50)));
        assert_eq!(index_map.get(4, &mut access), None);
        assert_eq!(index_map.get(69, &mut access), None);
        assert_eq!(index_map.get(71, &mut access), None);
    }

    #[test]
    #[should_panic]
    fn wrong_push_access_hint_crashes() {
        let mut index_map = IndexMap::new();
        let mut local_access = IndexMapLocalAccessOptimizer::new();
        let mut access = IndexMapAccessOptimizer::Local(&mut local_access);
        index_map.set(0, Opsk::with_value(0), &mut access);
        index_map.set(1, Opsk::with_value(1), &mut access);
        index_map.set(2, Opsk::with_value(50), &mut access);
        index_map.set(70, Opsk::with_value(50), &mut access);
        // Wrong hint!
        index_map.set(3, Opsk::with_value(50), &mut IndexMapAccessOptimizer::Push);
        index_map.set(8, Opsk::with_value(100), &mut access);
    }

    #[test]
    #[should_panic]
    fn wrong_pop_access_hint_crashes() {
        let mut index_map = IndexMap::new();
        let mut local_access = IndexMapLocalAccessOptimizer::new();
        let mut access = IndexMapAccessOptimizer::Local(&mut local_access);
        index_map.set(0, Opsk::with_value(0), &mut access);
        index_map.set(1, Opsk::with_value(1), &mut access);
        // Wrong hint!
        index_map.set(2, Opsk::with_value(50), &mut IndexMapAccessOptimizer::Pop);
        index_map.set(70, Opsk::with_value(50), &mut access);
        index_map.set(3, Opsk::with_value(50), &mut access);
        index_map.set(8, Opsk::with_value(100), &mut access);
    }
}
